<!DOCTYPE html><html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel="canonical" href="https://corlaez.com/note/8.html">
    <link rel="alternate" hreflang="es" href="https://corlaez.com/es/note/8.html">
    <link rel="stylesheet" href="/styles.css">
    <meta name="viewport" content="user-scalable=yes, width=device-width,initial-scale=1,shrink-to-fit=no">
    <meta name="robots" content="index, follow">
    <title>This talk by Marty Pitt has low-key blow</title>
    <meta name="description" content="This talk by Marty Pitt has low-key blown my mind: https://www.youtube.com/watch?v=GUAVOkz_zWU

Despite the type-aliases in the title, that seems to be the least important part of the talk. Some quick notes:

- Distinguish between Semantic Contract and Structural Contract
- Makes a point on how Semantic Contracts are easier to share and encourages to do so
- Makes a point on how Structural Contracts are a pain to share and encourages to keep that private
- Taxi language can define semantic contracts. You can use Kotlin type aliases to write taxi semantic contracts
- Orbitalhq is a docker image that can consume semantic contracts and register data sources (DB, Kafka, REST API, Soap, etc)
- This wasn't mentioned, but you pay for orbital, the free tier is very limited. Still amazing what it can achieve.
- You can use taxi language queries to request an arbitrary structure of semantic data. (can also be written in Kotlin)
- Orbital can then automatically reach to the different sources and look for the semantic data and arrange it as requested

The result is:
- A single, *formal*, definition (across teams) of the semantic contracts
- Clients do not care where the semantic data is coming from. Resilient to changes.
- Orbital automates SQL, Kafka, REST glue code reducing overall code required.

My concerns:
- Does Orbital have any permission management? Exposing DB model and data seems dangerous without it.
- Can contract sync be an issue?

Overall what orbital does is impressive. I don't think I have seen it elsewhere. Nothing here is really Kotlin 
specific besides the fact that you can define taxi lang constructs (contracts and queries) with type safe Kotlin 
which actually is convenient as well.
">
    <meta name="theme-color" content="#A10000">
    <meta name="author" content="Armando Cordova">
    <meta property="og:title" content="This talk by Marty Pitt has low-key blow">
    <meta property="og:description" content="This talk by Marty Pitt has low-key blown my mind: https://www.youtube.com/watch?v=GUAVOkz_zWU

Despite the type-aliases in the title, that seems to be the least important part of the talk. Some quick notes:

- Distinguish between Semantic Contract and Structural Contract
- Makes a point on how Semantic Contracts are easier to share and encourages to do so
- Makes a point on how Structural Contracts are a pain to share and encourages to keep that private
- Taxi language can define semantic contracts. You can use Kotlin type aliases to write taxi semantic contracts
- Orbitalhq is a docker image that can consume semantic contracts and register data sources (DB, Kafka, REST API, Soap, etc)
- This wasn't mentioned, but you pay for orbital, the free tier is very limited. Still amazing what it can achieve.
- You can use taxi language queries to request an arbitrary structure of semantic data. (can also be written in Kotlin)
- Orbital can then automatically reach to the different sources and look for the semantic data and arrange it as requested

The result is:
- A single, *formal*, definition (across teams) of the semantic contracts
- Clients do not care where the semantic data is coming from. Resilient to changes.
- Orbital automates SQL, Kafka, REST glue code reducing overall code required.

My concerns:
- Does Orbital have any permission management? Exposing DB model and data seems dangerous without it.
- Can contract sync be an issue?

Overall what orbital does is impressive. I don't think I have seen it elsewhere. Nothing here is really Kotlin 
specific besides the fact that you can define taxi lang constructs (contracts and queries) with type safe Kotlin 
which actually is convenient as well.
">
    <meta property="og:url" content="https://corlaez.com">
    <meta property="og:type" content="article">
    <meta property="og:article:author" content="Armando Cordova">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="Corlaez Blog">
    <meta property="og:image" content="/assets/banner2.png">
    <meta name="twitter:image" content="/assets/banner2.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image:alt" content="Logo that reads A R">
    <meta name="twitter:creator" content="@corlaez">
    <meta name="twitter:site" content="@corlaez">
    <meta name="twitter:site_name" content="@corlaez">
    <meta name="twitter:title" content="This talk by Marty Pitt has low-key blow">
    <meta name="twitter:description" content="This talk by Marty Pitt has low-key blown my mind: https://www.youtube.com/watch?v=GUAVOkz_zWU

Despite the type-aliases in the title, that seems to be the least important part of the talk. Some quick notes:

- Distinguish between Semantic Contract and Structural Contract
- Makes a point on how Semantic Contracts are easier to share and encourages to do so
- Makes a point on how Structural Contracts are a pain to share and encourages to keep that private
- Taxi language can define semantic contracts. You can use Kotlin type aliases to write taxi semantic contracts
- Orbitalhq is a docker image that can consume semantic contracts and register data sources (DB, Kafka, REST API, Soap, etc)
- This wasn't mentioned, but you pay for orbital, the free tier is very limited. Still amazing what it can achieve.
- You can use taxi language queries to request an arbitrary structure of semantic data. (can also be written in Kotlin)
- Orbital can then automatically reach to the different sources and look for the semantic data and arrange it as requested

The result is:
- A single, *formal*, definition (across teams) of the semantic contracts
- Clients do not care where the semantic data is coming from. Resilient to changes.
- Orbital automates SQL, Kafka, REST glue code reducing overall code required.

My concerns:
- Does Orbital have any permission management? Exposing DB model and data seems dangerous without it.
- Can contract sync be an issue?

Overall what orbital does is impressive. I don't think I have seen it elsewhere. Nothing here is really Kotlin 
specific besides the fact that you can define taxi lang constructs (contracts and queries) with type safe Kotlin 
which actually is convenient as well.
">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/favicon/apple-icon-76x76.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicon/favicon-96x96.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192"  href="/assets/favicon/android-icon-192x192.png"><link rel="manifest" href="/manifest.json"><link rel="shortcut icon" href="/favicon.ico"><meta name="msapplication-TileColor" content="#A10000"><meta name="msapplication-TileImage" content="/assets/favicon/ms-icon-144x144.png">    <script>if('serviceWorker' in navigator){
navigator.serviceWorker.register("/serviceWorker.js")}</script>
    <link rel="webmention" href="https://webmention.io/corlaez.com/webmention">
    <link rel="pingback" href="https://webmention.io/corlaez.com/xmlrpc">
    <link rel="authorization_endpoint" href="https://indieauth.com/auth">
    <link rel="token_endpoint" href="https://tokens.indieauth.com/token">
    <link rel="microsub" href="https://aperture.p3k.io/microsub/781">
    <link rel="stylesheet" href="/assets/prism.css">
    <link rel="preload" href="/assets/dark-red.webp" as="image">
  </head>
  <body class="h-entry">
    <nav><a href="/">Blog</a> <a class="selected" href="/note">Notes</a> <a href="/board.html" rel="">Board</a> <a href="/legal.html" rel="legal privacy">Legal</a>  <a href="/es/note/8.html">Versi√≥n en Espa√±ol</a></nav>
    <main class="content e-content"><p><a class="u-url" href="https://corlaez.com/note/8.html"><em><time class="dt-published" datetime="2023-03-23T00:00:00">Mar 23, 2023</time></em></a></p>
<p>This talk by Marty Pitt has low-key blown my mind: https://www.youtube.com/watch?v=GUAVOkz_zWU</p><p>Despite the type-aliases in the title, that seems to be the least important part of the talk. Some quick notes:</p><ul><li>Distinguish between Semantic Contract and Structural Contract</li><li>Makes a point on how Semantic Contracts are easier to share and encourages to do so</li><li>Makes a point on how Structural Contracts are a pain to share and encourages to keep that private</li><li>Taxi language can define semantic contracts. You can use Kotlin type aliases to write taxi semantic contracts</li><li>Orbitalhq is a docker image that can consume semantic contracts and register data sources (DB, Kafka, REST API, Soap, etc)</li><li>This wasn't mentioned, but you pay for orbital, the free tier is very limited. Still amazing what it can achieve.</li><li>You can use taxi language queries to request an arbitrary structure of semantic data. (can also be written in Kotlin)</li><li>Orbital can then automatically reach to the different sources and look for the semantic data and arrange it as requested</li></ul><p>The result is:</p><ul><li>A single, <em>formal</em>, definition (across teams) of the semantic contracts</li><li>Clients do not care where the semantic data is coming from. Resilient to changes.</li><li>Orbital automates SQL, Kafka, REST glue code reducing overall code required.</li></ul><p>My concerns:</p><ul><li>Does Orbital have any permission management? Exposing DB model and data seems dangerous without it.</li><li>Can contract sync be an issue?</li></ul><p>Overall what orbital does is impressive. I don't think I have seen it elsewhere. Nothing here is really Kotlin
specific besides the fact that you can define taxi lang constructs (contracts and queries) with type safe Kotlin
which actually is convenient as well.</p></main>
    <footer>
      <div class="h-card p-author">
        <p class="center signature"><img class="u-photo" alt="Logo that reads A R" loading="lazy" src="/assets/signature-white-210.png" width="210" height="210"></p>
        <p><a class="u-url u-uid" href="https://corlaez.com">corlaez.com</a> has been brought to you by <span class="p-name">Armando Cordova</span>. Thanks for your visit.</p>
        <p class="center"><a class="u-url" href="https://github.com/corlaez" rel="me authn nofollow noreferrer noopener">Github</a> <a class="u-url" href="https://linkedin.com/in/corlaez" rel="me nofollow noreferrer noopener">LinkedIn</a> <a class="u-url" href="https://twitter.com/corlaez" rel="me nofollow noreferrer noopener">Twitter</a></p>
      </div>
      <p class="center"><a class="u-url" href="https://xn--sr8hvo.ws/previous" rel="nofollow noreferrer noopener">‚Üê</a> An <a class="u-url" href="https://xn--sr8hvo.ws" rel="nofollow noreferrer noopener">IndieWeb Webring</a> üï∏üíç <a class="u-url" href="https://xn--sr8hvo.ws/next" rel="nofollow noreferrer noopener">‚Üí</a></p>
      <script src="/assets/prism.js"></script>
    </footer>
  </body>
</html>
